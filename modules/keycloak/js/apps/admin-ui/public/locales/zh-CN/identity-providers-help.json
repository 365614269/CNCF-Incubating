{
  "redirectURI": "配置身份供应商时使用的重定向 uri。",
  "alias": "别名唯一标识身份供应商，它也用于构建重定向 uri。",
  "displayName": "身份供应商的友好名称。",
  "clientId": "向身份供应商注册的客户端标识符。",
  "clientSecret": "向身份供应商注册的客户端密码。该字段可以从保险库中获取其值，使用 ${vault.ID} 格式。",
  "displayOrder": "数字定义供应商在 GUI 中的顺序（例如，在登录页面上）。最小的数字将首先被应用。",
  "endpoints": "显示服务提供商终端节点（Endpoint）的配置",
  "useDiscoveryEndpoint": "如果启用此设置，发现端点将用于获取供应商配置。Keycloak 可以从终端节点加载配置并在源有任何更新时自动更新配置",
  "discoveryEndpoint": "从远程 IDP 发现描述符导入元数据。",
  "importConfig": "从下载的 IDP 发现描述符中导入元数据。",
  "passLoginHint": "将 login_hint 传递给身份供应商。",
  "passMaxAge": "将 max_age 传递给身份供应商。",
  "passCurrentLocale": "将当前语言环境作为 ui_locales 参数传递给身份供应商。",
  "logoutUrl": "结束用于从外部 IDP 注销用户的会话端点。",
  "backchannelLogout": "外部 IDP 是否支持后台注销？",
  "disableUserInfo": "禁止使用用户信息服务来获取额外的用户信息？默认是使用这个 OIDC 服务。",
  "userInfoUrl": "用户信息 Url。这是可选的。",
  "issuer": "响应发布者的发布者标识符。如果未提供，则不会执行任何验证。",
  "scopes": "请求授权时要发送的范围。它可以是一个以空格分隔的范围列表。默认为'openid'。",
  "prompt": "指定授权服务器是否提示最终用户重新验证和授权。",
  "acceptsPromptNone": "这只是与身份供应商验证器一起使用，或者当kc_idp_hint指向这个身份供应商时。如果客户端发送一个prompt=none的请求并且用户还没有被认证，错误将不会直接返回给客户端, 但带有 prompt=none 的请求将被转发给这个身份供应商。",
  "validateSignature": "启用/禁用外部 IDP 签名的签名验证。",
  "useJwksUrl": "如果开关打开，身份供应商公钥将从给定的 JWKS URL 下载。这具有很大的灵活性，因为当身份供应商生成新的密钥对时，新密钥总是会再次重新下载。如果开关关闭，则使用来自 Keycloak 的公钥（或证书）。因此当身份供应商密钥对发生变化时，您始终需要将新密钥也导入 Keycloak 数据库。",
  "validatingPublicKey": "必须用于验证外部 IDP 签名的 PEM 格式的公钥。",
  "validatingPublicKeyId": "如果是密钥 ID，则上面给出的验证公钥的显式 ID。如果上面的密钥被始终使用，则可以留空，不管外部 IDP 指定的密钥 ID。如果密钥仅用于验证，则设置它如果来自外部 IDP 的密钥 ID 匹配。",
  "jwksUrl": "存储 JWK 格式的身份供应商密钥的 URL。有关更多详细信息，请参阅 JWK 规范。如果您使用外部 Keycloak 身份供应商，则可以使用类似“http://broker-keycloak:8180/realms/test”的 URL /protocol/openid-connect/certs' 假设您的代理 Keycloak 在 'http://broker-keycloak:8180' 上运行并且它的领域是 'test' 。",
  "pkceEnabled": "使用 PKCE（密钥代码交换证明）进行 IdP 代理",
  "pkceMethod": "使用的 PKCE 方法",
  "allowedClockSkew": "验证身份供应商令牌时可以允许的时钟偏差秒数。默认值为零。",
  "attributeConsumingServiceIndex": "在身份验证期间请求的属性消费服务配置文件的索引。",
  "attributeConsumingServiceName": "要在 SP 元数据中通告的属性消费服务配置文件的名称。",
  "forwardParameters": "非 OpenID Connect/OAuth 标准查询参数，从初始应用请求到授权端点转发到外部 IDP。可以输入多个参数，以英文逗号 (,) 分隔。",
  "clientAuthentication": "客户端身份验证方法（参见 https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication）。如果 JWT 使用私钥签名，则使用领域私钥。",
  "clientAssertionSigningAlg": "签名算法创建JWT断言作为客户端身份验证。需要使用私钥或客户端秘密作为JWT签名的JWT。如果没有指定算法，则适配以下算法。在RS256中适配RS256使用私钥签名的 JWT 的情况。HS256 适用于客户端机密作为 jwt 的情况。",
  "storeTokens": "如果必须在验证用户身份后存储令牌，则可以启用/禁用。",
  "storedTokensReadable": "如果新用户可以读取任何存储的令牌，则启用/禁用。这会分配 broker.read-token 角色。",
  "trustEmail": "如果启用，即使为领域启用了验证，也不会验证此提供商提供的电子邮件。",
  "accountLinkingOnly": "如果为真，则用户无法通过此提供程序登录。他们只能链接到此提供程序。当不想允许从提供程序登录，但想与提供程序集成时，这会很有用",
  "hideOnLoginPage": "如果隐藏，只有在明确请求时才能使用此提供程序登录，例如使用'kc_idp_hint'参数。",
  "firstBrokerLoginFlowAlias": "身份验证流程的别名，在首次使用此身份供应商登录后触发。术语“首次登录”表示当前没有 Keycloak 帐户链接到经过身份验证的身份供应商帐户。",
  "postBrokerLoginFlowAlias": "身份验证流程的别名，在每次使用此身份供应商登录后触发。如果您希望对使用此身份供应商（例如 OTP）进行身份验证的每个用户进行额外验证，则很有用。将此设置为“无”，如果使用此身份供应商登录后，您不需要触发任何其他身份验证器。另请注意，身份验证器实现必须假定用户已在用户会话中设置，因为身份供应商已对其进行设置。",
  "syncMode": "所有映射器的默认同步模式。同步模式决定何时使用映射器同步用户数据。可能的值是：'引用' 保持引入此选项之前的行为，'导入' 仅导入在用户首次使用此身份供应商登录期间，用户一次，“强制”在每次使用此身份供应商登录期间始终更新用户。",
  "serviceProviderEntityId": "将用于唯一标识此 SAML 服务提供商的实体 ID。",
  "identityProviderEntityId": "实体 ID 用于验证收到的 SAML 断言的颁发者。如果为空，则不执行颁发者验证。",
  "useEntityDescriptor": "从远程 IDP SAML 实体描述符导入元数据。",
  "samlEntityDescriptor": "允许您从配置文件加载外部 IDP 元数据或从 URL 下载它。",
  "ssoServiceUrl": "必须用于发送身份验证请求 (SAML验证请求) 的 Url。",
  "singleLogoutServiceUrl": "必须用于发送注销请求的 Url。",
  "nameIdPolicyFormat": "指定与名称标识符格式对应的 URI 引用。",
  "principalType": "从断言中识别和跟踪外部用户的方法。默认使用 Subject NameID，或者您可以设置识别属性。",
  "principalAttribute": "用于识别外部用户属性的名称或友好的名称。",
  "allowCreate": "允许外部身份供应商创建一个新的标识符来代表委托人。",
  "httpPostBindingResponse": "指示是否响应使用 HTTP-POST 绑定的请求。如果为否，将使用 HTTP-REDIRECT 绑定。",
  "httpPostBindingAuthnRequest": "指示是否必须使用 HTTP-POST 绑定发送验证请求。如果为否，将使用 HTTP-REDIRECT 绑定。",
  "httpPostBindingLogout": "指示是否使用 HTTP-POST 绑定响应请求。如果为否，将使用 HTTP-REDIRECT 绑定。",
  "wantAuthnRequestsSigned": "指示身份供应商是否需要签名的验证请求。",
  "signatureAlgorithm": "用于签署文档的签名算法。请注意，基于 'SHA1' 的算法已被弃用，将来可能会被删除。建议坚持使用一些更安全的算法而不是 '*_SHA1'",
  "encryptionAlgorithm": "SAML IDP 用于加密 SAML 文档、断言或 ID 的加密算法。解密 SAML 文档部分的相应解密密钥将根据此配置的算法选择，并且应该在领域密钥中可用加密 (ENC) 使用。如果未配置算法，则允许使用任何支持的算法，并且将根据 SAML 文档本身配置的算法选择解密密钥。",
  "samlSignatureKeyName": "已签名的 SAML 文档在 KeyName 元素中包含签名密钥的标识。对于 Keycloak / RH-SSO 对方，使用 KEY_ID，对于 MS AD FS 使用 CERT_SUBJECT，对于其他人，如果没有其他有效的选项，请查看并使用 NONE。",
  "wantAssertionsSigned": "表明该服务供应商是否需要一个已签名的断言。",
  "wantAssertionsEncrypted": "表明此服务提供商是否需要加密断言。",
  "forceAuthentication": "指示身份供应商是否必须直接验证呈现者而不是依赖先前的安全上下文。",
  "validateSignatures": "启用/禁用 SAML 响应的签名验证。",
  "validatingX509Certs": "必须用于检查签名的PEM格式的证书。可以输入多个证书，以英文逗号(,)分隔。",
  "signServiceProviderMetadata": "启用/禁用提供商 SAML 元数据的签名。",
  "passSubject": "在登录阶段，将可选的 login_hint 查询参数转发给 SAML 验证请求的主题。",
  "comparison": "指定用于评估请求的上下文类或语句的比较方法。默认为\"Exact\"。",
  "authnContextClassRefs": "请求的 AuthnContext ClassRefs 的有序列表。",
  "authnContextDeclRefs": "请求的 AuthnContext DeclRefs 的有序列表。",
  "addIdpMapperName": "映射器的名称。",
  "syncModeOverride": "覆盖此映射器的 IDP 的默认同步模式。值是：'引用' 以保持引入此选项之前的行为，'导入' 仅在用户首次登录时导入用户一次身份供应商，“强制”在每次使用此身份供应商登录期间始终更新用户，并“继承”使用身份供应商中为此映射器定义的同步模式。",
  "advancedAttributeToRole": "如果属性集存在并且可以匹配，则授予用户指定的领域或客户端角色。",
  "usernameTemplateImporter": "格式化要导入的用户名。",
  "hardcodedUserSessionAttribute": "当用户从供应商导入时，将一个值硬编码到特定的用户会话属性。",
  "externalRoleToRole": "在 keycloak 访问令牌中寻找外部角色。如果存在外部角色，则授予用户指定的领域或客户端角色。",
  "advancedClaimToRole": "如果所有声明都存在，则授予用户指定的领域或客户端角色。",
  "claimToRole": "如果存在声明，则授予用户指定的领域或客户端角色。",
  "oidcAttributeImporter": "将声明的声明（如果存在于 ID、访问令牌或用户配置文件端点返回的声明集中）导入到指定的用户属性或属性中。",
  "attributeImporter": "如果断言中存在声明的 SAML 属性，则将其导入指定的用户属性或属性。",
  "hardcodedRole": "当用户从供应商导入时，为它硬编码一个角色映射。",
  "hardcodedAttribute": "当用户从供应商导入时，将一个值硬编码到特定的用户属性。",
  "samlAttributeToRole": "如果属性存在，则授予用户指定的领域或客户端角色。",
  "template": "用于格式化要导入的用户名的模板。替换包含在 ${} 中。例如：'${ALIAS}.${CLAIM.sub}'。ALIAS 是供应商别名。CLAIM.<NAME > 引用 ID 或访问令牌声明。可以通过将 |uppercase 或 |lowercase 附加到替换值来将替换转换为大写或小写，例如“${CLAIM.sub | lowercase}”。",
  "target": "映射器的目标字段。LOCAL（默认）表示更改应用于用户导入时存储在本地数据库中的用户名。BROKER_ID 和 BROKER_USERNAME 表示更改存储在用于联合用户的 ID 或用户名中分别查找。",
  "userSessionAttribute": "您要硬编码的用户会话属性的名称",
  "userAttribute": "您要硬编码的用户属性的名称",
  "claim": "要在令牌中搜索的声明名称。您可以使用'.'引用嵌套声明，即'address.locality'。要按字面意思使用点 (.)，请使用反斜杠将其转义。(\\. )",
  "socialProfileJSONFieldPath": "从社交供应商用户配置文件 JSON 数据中获取值的字段路径。您可以使用圆点表示法进行嵌套，使用方括号表示数组索引。例如 'contact.address[0].country'。",
  "userAttributeValue": "你想要硬编码的值",
  "attributeName": "要在断言中搜索的属性名称。您可以将此留空并指定一个友好的名称。",
  "friendlyName": "断言中要搜索的属性的友好名称。您可以将此留空并指定一个名称。",
  "userAttributeName": "用于存储 SAML 属性的用户属性名称。使用电子邮件、姓氏和名字映射到那些预定义的用户属性。",
  "socialUserAttributeName": "存储信息的用户属性名。",
  "attributeValue": "属性必须具有的值。如果属性是列表，则该值必须包含在列表中。",
  "attributes": "要在令牌中搜索的属性的名称和（正则表达式）值。在 SAML 属性名称和属性友好名称字段中搜索属性的配置名称。必须满足每个给定的属性描述才能设置角色。如果属性是一个数组，那么这个值必须包含在数组中。如果一个属性可以多次找到，那么一次匹配就足够了。",
  "regexAttributeValues": "如果启用的属性值被解释为正则表达式。",
  "role": "如果所有属性都存在，则授予用户的角色。单击“选择角色”按钮浏览角色，或直接在文本框中键入。要引用客户端角色，语法为 clientname.clientrole，即 myclient.myrole。 ",
  "baseUrl": "覆写此身份供应商的默认基本 URL。",
  "apiUrl": "覆写此身份供应商的默认 API URL。",
  "facebook": {
    "fetchedFields": "提供将使用配置文件请求获取的附加字段。这将附加到默认的 'id,name,email,first_name,last_name' 集合。"
  },
  "google": {
    "hostedDomain": "使用 Google 登录时设置‘hd’查询参数。Google 将仅列出该域的帐户。Keycloak 验证返回的身份令牌是否具有该域的声明。输入‘*’时，任何托管帐户可以使用。支持英文逗号 ',' 分隔域列表。",
    "userIp": "在调用 Google 的用户信息服务时设置 'userIp' 查询参数。这将使用用户的 IP 地址。如果 Google 正在限制对用户信息服务的访问，这很有用。",
    "offlineAccess": "在重定向到谷歌授权端点时将‘access_type’查询参数设置为‘离线’，以获取刷新令牌。如果计划在用户离线时使用令牌交换检索谷歌令牌以访问谷歌 API，则将很有用。"
  },
  "openshift": {
    "baseUrl": "OpenShift Online API 的基本 Url"
  },
  "paypal": {
    "sandbox": "目标 PayPal 的沙箱环境"
  },
  "stackoverflow": {
    "key": "从 Stack Overflow 客户端注册获得的 Key。"
  },
  "linkedin": {
    "profileProjection": "配置文件请求的开放参数。默认无任何开放。"
  }
}
