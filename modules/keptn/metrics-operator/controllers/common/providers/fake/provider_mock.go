// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package fake

import (
	"context"
	metricsapi "github.com/keptn/lifecycle-toolkit/metrics-operator/api/v1"
	"sync"
)

// KeptnSLIProviderMock is a mock implementation of providers.KeptnSLIProvider.
//
//	func TestSomethingThatUsesKeptnSLIProvider(t *testing.T) {
//
//		// make and configure a mocked providers.KeptnSLIProvider
//		mockedKeptnSLIProvider := &KeptnSLIProviderMock{
//			EvaluateQueryFunc: func(ctx context.Context, metric metricsapi.KeptnMetric, provider metricsapi.KeptnMetricsProvider) (string, []byte, error) {
//				panic("mock out the EvaluateQuery method")
//			},
//			EvaluateQueryForStepFunc: func(ctx context.Context, metric metricsapi.KeptnMetric, provider metricsapi.KeptnMetricsProvider) ([]string, []byte, error) {
//				panic("mock out the EvaluateQueryForStep method")
//			},
//			FetchAnalysisValueFunc: func(ctx context.Context, query string, spec metricsapi.Analysis, provider *metricsapi.KeptnMetricsProvider) (string, error) {
//				panic("mock out the FetchAnalysisValue method")
//			},
//		}
//
//		// use mockedKeptnSLIProvider in code that requires providers.KeptnSLIProvider
//		// and then make assertions.
//
//	}
type KeptnSLIProviderMock struct {
	// EvaluateQueryFunc mocks the EvaluateQuery method.
	EvaluateQueryFunc func(ctx context.Context, metric metricsapi.KeptnMetric, provider metricsapi.KeptnMetricsProvider) (string, []byte, error)

	// EvaluateQueryForStepFunc mocks the EvaluateQueryForStep method.
	EvaluateQueryForStepFunc func(ctx context.Context, metric metricsapi.KeptnMetric, provider metricsapi.KeptnMetricsProvider) ([]string, []byte, error)

	// FetchAnalysisValueFunc mocks the FetchAnalysisValue method.
	FetchAnalysisValueFunc func(ctx context.Context, query string, spec metricsapi.Analysis, provider *metricsapi.KeptnMetricsProvider) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// EvaluateQuery holds details about calls to the EvaluateQuery method.
		EvaluateQuery []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Metric is the metric argument value.
			Metric metricsapi.KeptnMetric
			// Provider is the provider argument value.
			Provider metricsapi.KeptnMetricsProvider
		}
		// EvaluateQueryForStep holds details about calls to the EvaluateQueryForStep method.
		EvaluateQueryForStep []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Metric is the metric argument value.
			Metric metricsapi.KeptnMetric
			// Provider is the provider argument value.
			Provider metricsapi.KeptnMetricsProvider
		}
		// FetchAnalysisValue holds details about calls to the FetchAnalysisValue method.
		FetchAnalysisValue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query string
			// Spec is the spec argument value.
			Spec metricsapi.Analysis
			// Provider is the provider argument value.
			Provider *metricsapi.KeptnMetricsProvider
		}
	}
	lockEvaluateQuery        sync.RWMutex
	lockEvaluateQueryForStep sync.RWMutex
	lockFetchAnalysisValue   sync.RWMutex
}

// EvaluateQuery calls EvaluateQueryFunc.
func (mock *KeptnSLIProviderMock) EvaluateQuery(ctx context.Context, metric metricsapi.KeptnMetric, provider metricsapi.KeptnMetricsProvider) (string, []byte, error) {
	if mock.EvaluateQueryFunc == nil {
		panic("KeptnSLIProviderMock.EvaluateQueryFunc: method is nil but KeptnSLIProvider.EvaluateQuery was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Metric   metricsapi.KeptnMetric
		Provider metricsapi.KeptnMetricsProvider
	}{
		Ctx:      ctx,
		Metric:   metric,
		Provider: provider,
	}
	mock.lockEvaluateQuery.Lock()
	mock.calls.EvaluateQuery = append(mock.calls.EvaluateQuery, callInfo)
	mock.lockEvaluateQuery.Unlock()
	return mock.EvaluateQueryFunc(ctx, metric, provider)
}

// EvaluateQueryCalls gets all the calls that were made to EvaluateQuery.
// Check the length with:
//
//	len(mockedKeptnSLIProvider.EvaluateQueryCalls())
func (mock *KeptnSLIProviderMock) EvaluateQueryCalls() []struct {
	Ctx      context.Context
	Metric   metricsapi.KeptnMetric
	Provider metricsapi.KeptnMetricsProvider
} {
	var calls []struct {
		Ctx      context.Context
		Metric   metricsapi.KeptnMetric
		Provider metricsapi.KeptnMetricsProvider
	}
	mock.lockEvaluateQuery.RLock()
	calls = mock.calls.EvaluateQuery
	mock.lockEvaluateQuery.RUnlock()
	return calls
}

// EvaluateQueryForStep calls EvaluateQueryForStepFunc.
func (mock *KeptnSLIProviderMock) EvaluateQueryForStep(ctx context.Context, metric metricsapi.KeptnMetric, provider metricsapi.KeptnMetricsProvider) ([]string, []byte, error) {
	if mock.EvaluateQueryForStepFunc == nil {
		panic("KeptnSLIProviderMock.EvaluateQueryForStepFunc: method is nil but KeptnSLIProvider.EvaluateQueryForStep was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Metric   metricsapi.KeptnMetric
		Provider metricsapi.KeptnMetricsProvider
	}{
		Ctx:      ctx,
		Metric:   metric,
		Provider: provider,
	}
	mock.lockEvaluateQueryForStep.Lock()
	mock.calls.EvaluateQueryForStep = append(mock.calls.EvaluateQueryForStep, callInfo)
	mock.lockEvaluateQueryForStep.Unlock()
	return mock.EvaluateQueryForStepFunc(ctx, metric, provider)
}

// EvaluateQueryForStepCalls gets all the calls that were made to EvaluateQueryForStep.
// Check the length with:
//
//	len(mockedKeptnSLIProvider.EvaluateQueryForStepCalls())
func (mock *KeptnSLIProviderMock) EvaluateQueryForStepCalls() []struct {
	Ctx      context.Context
	Metric   metricsapi.KeptnMetric
	Provider metricsapi.KeptnMetricsProvider
} {
	var calls []struct {
		Ctx      context.Context
		Metric   metricsapi.KeptnMetric
		Provider metricsapi.KeptnMetricsProvider
	}
	mock.lockEvaluateQueryForStep.RLock()
	calls = mock.calls.EvaluateQueryForStep
	mock.lockEvaluateQueryForStep.RUnlock()
	return calls
}

// FetchAnalysisValue calls FetchAnalysisValueFunc.
func (mock *KeptnSLIProviderMock) FetchAnalysisValue(ctx context.Context, query string, spec metricsapi.Analysis, provider *metricsapi.KeptnMetricsProvider) (string, error) {
	if mock.FetchAnalysisValueFunc == nil {
		panic("KeptnSLIProviderMock.FetchAnalysisValueFunc: method is nil but KeptnSLIProvider.FetchAnalysisValue was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Query    string
		Spec     metricsapi.Analysis
		Provider *metricsapi.KeptnMetricsProvider
	}{
		Ctx:      ctx,
		Query:    query,
		Spec:     spec,
		Provider: provider,
	}
	mock.lockFetchAnalysisValue.Lock()
	mock.calls.FetchAnalysisValue = append(mock.calls.FetchAnalysisValue, callInfo)
	mock.lockFetchAnalysisValue.Unlock()
	return mock.FetchAnalysisValueFunc(ctx, query, spec, provider)
}

// FetchAnalysisValueCalls gets all the calls that were made to FetchAnalysisValue.
// Check the length with:
//
//	len(mockedKeptnSLIProvider.FetchAnalysisValueCalls())
func (mock *KeptnSLIProviderMock) FetchAnalysisValueCalls() []struct {
	Ctx      context.Context
	Query    string
	Spec     metricsapi.Analysis
	Provider *metricsapi.KeptnMetricsProvider
} {
	var calls []struct {
		Ctx      context.Context
		Query    string
		Spec     metricsapi.Analysis
		Provider *metricsapi.KeptnMetricsProvider
	}
	mock.lockFetchAnalysisValue.RLock()
	calls = mock.calls.FetchAnalysisValue
	mock.lockFetchAnalysisValue.RUnlock()
	return calls
}
