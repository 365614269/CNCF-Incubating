## API Report File for "@backstage/plugin-scaffolder-node"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
/// <reference types="node" />

import { JsonObject } from '@backstage/types';
import { JsonValue } from '@backstage/types';
import { Logger } from 'winston';
import { Observable } from '@backstage/types';
import { Schema } from 'jsonschema';
import { ScmIntegrations } from '@backstage/integration';
import { SpawnOptionsWithoutStdio } from 'child_process';
import { TaskSpec } from '@backstage/plugin-scaffolder-common';
import { TemplateInfo } from '@backstage/plugin-scaffolder-common';
import { UrlReader } from '@backstage/backend-common';
import { UserEntity } from '@backstage/catalog-model';
import { Writable } from 'stream';
import { z } from 'zod';

// @public
export type ActionContext<
  TActionInput extends JsonObject,
  TActionOutput extends JsonObject = JsonObject,
> = {
  logger: Logger;
  logStream: Writable;
  secrets?: TaskSecrets;
  workspacePath: string;
  input: TActionInput;
  output(
    name: keyof TActionOutput,
    value: TActionOutput[keyof TActionOutput],
  ): void;
  createTemporaryDirectory(): Promise<string>;
  templateInfo?: TemplateInfo;
  isDryRun?: boolean;
  user?: {
    entity?: UserEntity;
    ref?: string;
  };
  signal?: AbortSignal;
  each?: JsonObject;
};

// @public
export const createTemplateAction: <
  TInputParams extends JsonObject = JsonObject,
  TOutputParams extends JsonObject = JsonObject,
  TInputSchema extends z.ZodType<any, z.ZodTypeDef, any> | Schema = {},
  TOutputSchema extends z.ZodType<any, z.ZodTypeDef, any> | Schema = {},
  TActionInput extends JsonObject = TInputSchema extends z.ZodType<
    any,
    any,
    infer IReturn
  >
    ? IReturn
    : TInputParams,
  TActionOutput extends JsonObject = TOutputSchema extends z.ZodType<
    any,
    any,
    infer IReturn_1
  >
    ? IReturn_1
    : TOutputParams,
>(
  action: TemplateActionOptions<
    TActionInput,
    TActionOutput,
    TInputSchema,
    TOutputSchema
  >,
) => TemplateAction<TActionInput, TActionOutput>;

// @public
export function executeShellCommand(
  options: ExecuteShellCommandOptions,
): Promise<void>;

// @public
export type ExecuteShellCommandOptions = {
  command: string;
  args: string[];
  options?: SpawnOptionsWithoutStdio;
  logStream?: Writable;
};

// @public
export function fetchContents(options: {
  reader: UrlReader;
  integrations: ScmIntegrations;
  baseUrl?: string;
  fetchUrl?: string;
  outputPath: string;
}): Promise<void>;

// @public
export function fetchFile(options: {
  reader: UrlReader;
  integrations: ScmIntegrations;
  baseUrl?: string;
  fetchUrl?: string;
  outputPath: string;
}): Promise<void>;

// @public
export type SerializedTask = {
  id: string;
  spec: TaskSpec;
  status: TaskStatus;
  createdAt: string;
  lastHeartbeatAt?: string;
  createdBy?: string;
  secrets?: TaskSecrets;
};

// @public
export type SerializedTaskEvent = {
  id: number;
  taskId: string;
  body: JsonObject;
  type: TaskEventType;
  createdAt: string;
};

// @public
export interface TaskBroker {
  // (undocumented)
  cancel?(taskId: string): Promise<void>;
  // (undocumented)
  claim(): Promise<TaskContext>;
  // (undocumented)
  dispatch(
    options: TaskBrokerDispatchOptions,
  ): Promise<TaskBrokerDispatchResult>;
  // (undocumented)
  event$(options: { taskId: string; after: number | undefined }): Observable<{
    events: SerializedTaskEvent[];
  }>;
  // (undocumented)
  get(taskId: string): Promise<SerializedTask>;
  // (undocumented)
  list?(options?: { createdBy?: string }): Promise<{
    tasks: SerializedTask[];
  }>;
  // (undocumented)
  vacuumTasks(options: { timeoutS: number }): Promise<void>;
}

// @public
export type TaskBrokerDispatchOptions = {
  spec: TaskSpec;
  secrets?: TaskSecrets;
  createdBy?: string;
};

// @public
export type TaskBrokerDispatchResult = {
  taskId: string;
};

// @public
export type TaskCompletionState = 'failed' | 'completed';

// @public
export interface TaskContext {
  // (undocumented)
  cancelSignal: AbortSignal;
  // (undocumented)
  complete(result: TaskCompletionState, metadata?: JsonObject): Promise<void>;
  // (undocumented)
  createdBy?: string;
  // (undocumented)
  done: boolean;
  // (undocumented)
  emitLog(message: string, logMetadata?: JsonObject): Promise<void>;
  // (undocumented)
  getWorkspaceName(): Promise<string>;
  // (undocumented)
  isDryRun?: boolean;
  // (undocumented)
  secrets?: TaskSecrets;
  // (undocumented)
  spec: TaskSpec;
}

// @public
export type TaskEventType = 'completion' | 'log' | 'cancelled';

// @public
export type TaskSecrets = Record<string, string> & {
  backstageToken?: string;
};

// @public
export type TaskStatus =
  | 'cancelled'
  | 'completed'
  | 'failed'
  | 'open'
  | 'processing';

// @public (undocumented)
export type TemplateAction<
  TActionInput extends JsonObject = JsonObject,
  TActionOutput extends JsonObject = JsonObject,
> = {
  id: string;
  description?: string;
  examples?: {
    description: string;
    example: string;
  }[];
  supportsDryRun?: boolean;
  schema?: {
    input?: Schema;
    output?: Schema;
  };
  handler: (ctx: ActionContext<TActionInput, TActionOutput>) => Promise<void>;
};

// @public (undocumented)
export type TemplateActionOptions<
  TActionInput extends JsonObject = {},
  TActionOutput extends JsonObject = {},
  TInputSchema extends Schema | z.ZodType = {},
  TOutputSchema extends Schema | z.ZodType = {},
> = {
  id: string;
  description?: string;
  examples?: TemplateExample[];
  supportsDryRun?: boolean;
  schema?: {
    input?: TInputSchema;
    output?: TOutputSchema;
  };
  handler: (ctx: ActionContext<TActionInput, TActionOutput>) => Promise<void>;
};

// @public (undocumented)
export type TemplateExample = {
  description: string;
  example: string;
};

// @public (undocumented)
export type TemplateFilter = (...args: JsonValue[]) => JsonValue | undefined;

// @public (undocumented)
export type TemplateGlobal =
  | ((...args: JsonValue[]) => JsonValue | undefined)
  | JsonValue;
```
