## API Report File for "@backstage/frontend-plugin-api"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
/// <reference types="react" />

import { AnyApiFactory } from '@backstage/core-plugin-api';
import { AnyApiRef } from '@backstage/core-plugin-api';
import { IconComponent } from '@backstage/core-plugin-api';
import { JsonObject } from '@backstage/types';
import { JSX as JSX_2 } from 'react';
import { default as React_2 } from 'react';
import { ReactNode } from 'react';
import { RouteRef } from '@backstage/core-plugin-api';
import { z } from 'zod';
import { ZodSchema } from 'zod';
import { ZodTypeDef } from 'zod';

// @public (undocumented)
export type AnyExtensionDataMap = {
  [name in string]: ExtensionDataRef<
    unknown,
    {
      optional?: true;
    }
  >;
};

// @public (undocumented)
export type AnyExtensionInputMap = {
  [inputName in string]: ExtensionInput<
    AnyExtensionDataMap,
    {
      optional: boolean;
      singleton: boolean;
    }
  >;
};

// @public (undocumented)
export interface BackstagePlugin {
  // (undocumented)
  $$type: '@backstage/BackstagePlugin';
  // (undocumented)
  extensions: Extension<unknown>[];
  // (undocumented)
  id: string;
}

// @public (undocumented)
export interface ConfigurableExtensionDataRef<
  TData,
  TConfig extends {
    optional?: true;
  } = {},
> extends ExtensionDataRef<TData, TConfig> {
  // (undocumented)
  optional(): ConfigurableExtensionDataRef<
    TData,
    TData & {
      optional: true;
    }
  >;
}

// @public (undocumented)
export const coreExtensionData: {
  reactElement: ConfigurableExtensionDataRef<JSX_2.Element, {}>;
  routePath: ConfigurableExtensionDataRef<string, {}>;
  apiFactory: ConfigurableExtensionDataRef<AnyApiFactory, {}>;
  routeRef: ConfigurableExtensionDataRef<RouteRef, {}>;
  navTarget: ConfigurableExtensionDataRef<NavTarget, {}>;
};

// @public (undocumented)
export function createApiExtension<
  TConfig extends {},
  TInputs extends AnyExtensionInputMap,
>(
  options: (
    | {
        api: AnyApiRef;
        factory: (options: {
          config: TConfig;
          inputs: Expand<ExtensionInputValues<TInputs>>;
        }) => AnyApiFactory;
      }
    | {
        factory: AnyApiFactory;
      }
  ) & {
    configSchema?: PortableSchema<TConfig>;
    inputs?: TInputs;
  },
): Extension<TConfig>;

// @public (undocumented)
export function createExtension<
  TOutput extends AnyExtensionDataMap,
  TInputs extends AnyExtensionInputMap,
  TConfig = never,
>(
  options: CreateExtensionOptions<TOutput, TInputs, TConfig>,
): Extension<TConfig>;

// @public (undocumented)
export function createExtensionDataRef<TData>(
  id: string,
): ConfigurableExtensionDataRef<TData>;

// @public (undocumented)
export function createExtensionInput<
  TExtensionData extends AnyExtensionDataMap,
  TConfig extends {
    singleton?: boolean;
    optional?: boolean;
  },
>(
  extensionData: TExtensionData,
  config?: TConfig,
): ExtensionInput<
  TExtensionData,
  {
    singleton: TConfig['singleton'] extends true ? true : false;
    optional: TConfig['optional'] extends true ? true : false;
  }
>;

// @public (undocumented)
export interface CreateExtensionOptions<
  TOutput extends AnyExtensionDataMap,
  TInputs extends AnyExtensionInputMap,
  TConfig,
> {
  // (undocumented)
  at: string;
  // (undocumented)
  configSchema?: PortableSchema<TConfig>;
  // (undocumented)
  disabled?: boolean;
  // (undocumented)
  factory(options: {
    source?: BackstagePlugin;
    bind(values: Expand<ExtensionDataValues<TOutput>>): void;
    config: TConfig;
    inputs: Expand<ExtensionInputValues<TInputs>>;
  }): void;
  // (undocumented)
  id: string;
  // (undocumented)
  inputs?: TInputs;
  // (undocumented)
  output: TOutput;
}

// @public
export function createNavItemExtension(options: {
  id: string;
  routeRef: RouteRef;
  title: string;
  icon: IconComponent;
}): Extension<{
  title: string;
}>;

// @public
export function createPageExtension<
  TConfig extends {
    path: string;
  },
  TInputs extends AnyExtensionInputMap,
>(
  options: (
    | {
        defaultPath: string;
      }
    | {
        configSchema: PortableSchema<TConfig>;
      }
  ) & {
    id: string;
    at?: string;
    disabled?: boolean;
    inputs?: TInputs;
    routeRef?: RouteRef;
    loader: (options: {
      config: TConfig;
      inputs: Expand<ExtensionInputValues<TInputs>>;
    }) => Promise<JSX.Element>;
  },
): Extension<TConfig>;

// @public (undocumented)
export function createPlugin(options: PluginOptions): BackstagePlugin;

// @public (undocumented)
export function createSchemaFromZod<TOutput, TInput>(
  schemaCreator: (zImpl: typeof z) => ZodSchema<TOutput, ZodTypeDef, TInput>,
): PortableSchema<TOutput>;

// @public (undocumented)
export interface Extension<TConfig> {
  // (undocumented)
  $$type: '@backstage/Extension';
  // (undocumented)
  at: string;
  // (undocumented)
  configSchema?: PortableSchema<TConfig>;
  // (undocumented)
  disabled: boolean;
  // (undocumented)
  factory(options: {
    source?: BackstagePlugin;
    bind(values: ExtensionInputValues<any>): void;
    config: TConfig;
    inputs: Record<
      string,
      undefined | Record<string, unknown> | Array<Record<string, unknown>>
    >;
  }): void;
  // (undocumented)
  id: string;
  // (undocumented)
  inputs: AnyExtensionInputMap;
  // (undocumented)
  output: AnyExtensionDataMap;
}

// @public (undocumented)
export function ExtensionBoundary(
  props: ExtensionBoundaryProps,
): React_2.JSX.Element;

// @public (undocumented)
export interface ExtensionBoundaryProps {
  // (undocumented)
  children: ReactNode;
  // (undocumented)
  source?: BackstagePlugin;
}

// @public (undocumented)
export type ExtensionDataRef<
  TData,
  TConfig extends {
    optional?: true;
  } = {},
> = {
  id: string;
  T: TData;
  config: TConfig;
  $$type: '@backstage/ExtensionDataRef';
};

// @public
export type ExtensionDataValues<TExtensionData extends AnyExtensionDataMap> = {
  [DataName in keyof TExtensionData as TExtensionData[DataName]['config'] extends {
    optional: true;
  }
    ? never
    : DataName]: TExtensionData[DataName]['T'];
} & {
  [DataName in keyof TExtensionData as TExtensionData[DataName]['config'] extends {
    optional: true;
  }
    ? DataName
    : never]?: TExtensionData[DataName]['T'];
};

// @public (undocumented)
export interface ExtensionInput<
  TExtensionData extends AnyExtensionDataMap,
  TConfig extends {
    singleton: boolean;
    optional: boolean;
  },
> {
  // (undocumented)
  $$type: '@backstage/ExtensionInput';
  // (undocumented)
  config: TConfig;
  // (undocumented)
  extensionData: TExtensionData;
}

// @public
export type ExtensionInputValues<
  TInputs extends {
    [name in string]: ExtensionInput<any, any>;
  },
> = {
  [InputName in keyof TInputs]: false extends TInputs[InputName]['config']['singleton']
    ? Array<Expand<ExtensionDataValues<TInputs[InputName]['extensionData']>>>
    : false extends TInputs[InputName]['config']['optional']
    ? Expand<ExtensionDataValues<TInputs[InputName]['extensionData']>>
    : Expand<
        ExtensionDataValues<TInputs[InputName]['extensionData']> | undefined
      >;
};

// @public (undocumented)
export type NavTarget = {
  title: string;
  icon: IconComponent;
  routeRef: RouteRef<{}>;
};

// @public (undocumented)
export interface PluginOptions {
  // (undocumented)
  extensions?: Extension<unknown>[];
  // (undocumented)
  id: string;
}

// @public (undocumented)
export type PortableSchema<TOutput> = {
  parse: (input: unknown) => TOutput;
  schema: JsonObject;
};

// @public (undocumented)
export function useRouteRef(routeRef: RouteRef<any>): () => string;
```
