## API Report File for "@backstage/frontend-plugin-api"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
/// <reference types="react" />

import { AlertApi } from '@backstage/core-plugin-api';
import { alertApiRef } from '@backstage/core-plugin-api';
import { AlertMessage } from '@backstage/core-plugin-api';
import { AnyApiFactory } from '@backstage/core-plugin-api';
import { AnyApiRef } from '@backstage/core-plugin-api';
import { ApiFactory } from '@backstage/core-plugin-api';
import { ApiHolder } from '@backstage/core-plugin-api';
import { ApiRef } from '@backstage/core-plugin-api';
import { ApiRefConfig } from '@backstage/core-plugin-api';
import { AppTheme } from '@backstage/core-plugin-api';
import { AppThemeApi } from '@backstage/core-plugin-api';
import { appThemeApiRef } from '@backstage/core-plugin-api';
import { atlassianAuthApiRef } from '@backstage/core-plugin-api';
import { AuthProviderInfo } from '@backstage/core-plugin-api';
import { AuthRequestOptions } from '@backstage/core-plugin-api';
import { BackstageIdentityApi } from '@backstage/core-plugin-api';
import { BackstageIdentityResponse } from '@backstage/core-plugin-api';
import { BackstagePlugin as BackstagePlugin_2 } from '@backstage/core-plugin-api';
import { BackstageUserIdentity } from '@backstage/core-plugin-api';
import { bitbucketAuthApiRef } from '@backstage/core-plugin-api';
import { bitbucketServerAuthApiRef } from '@backstage/core-plugin-api';
import { ComponentType } from 'react';
import { ConfigApi } from '@backstage/core-plugin-api';
import { configApiRef } from '@backstage/core-plugin-api';
import { createApiFactory } from '@backstage/core-plugin-api';
import { createApiRef } from '@backstage/core-plugin-api';
import { DiscoveryApi } from '@backstage/core-plugin-api';
import { discoveryApiRef } from '@backstage/core-plugin-api';
import { ErrorApi } from '@backstage/core-plugin-api';
import { ErrorApiError } from '@backstage/core-plugin-api';
import { ErrorApiErrorContext } from '@backstage/core-plugin-api';
import { errorApiRef } from '@backstage/core-plugin-api';
import { FeatureFlag } from '@backstage/core-plugin-api';
import { FeatureFlagsApi } from '@backstage/core-plugin-api';
import { featureFlagsApiRef } from '@backstage/core-plugin-api';
import { FeatureFlagsSaveOptions } from '@backstage/core-plugin-api';
import { FeatureFlagState } from '@backstage/core-plugin-api';
import { FetchApi } from '@backstage/core-plugin-api';
import { fetchApiRef } from '@backstage/core-plugin-api';
import { githubAuthApiRef } from '@backstage/core-plugin-api';
import { gitlabAuthApiRef } from '@backstage/core-plugin-api';
import { googleAuthApiRef } from '@backstage/core-plugin-api';
import { IconComponent as IconComponent_2 } from '@backstage/core-plugin-api';
import { IdentityApi } from '@backstage/core-plugin-api';
import { identityApiRef } from '@backstage/core-plugin-api';
import { JsonObject } from '@backstage/types';
import { JSX as JSX_2 } from 'react';
import { microsoftAuthApiRef } from '@backstage/core-plugin-api';
import { OAuthApi } from '@backstage/core-plugin-api';
import { OAuthRequestApi } from '@backstage/core-plugin-api';
import { oauthRequestApiRef } from '@backstage/core-plugin-api';
import { OAuthRequester } from '@backstage/core-plugin-api';
import { OAuthRequesterOptions } from '@backstage/core-plugin-api';
import { OAuthScope } from '@backstage/core-plugin-api';
import { oktaAuthApiRef } from '@backstage/core-plugin-api';
import { oneloginAuthApiRef } from '@backstage/core-plugin-api';
import { OpenIdConnectApi } from '@backstage/core-plugin-api';
import { PendingOAuthRequest } from '@backstage/core-plugin-api';
import { ProfileInfo } from '@backstage/core-plugin-api';
import { ProfileInfoApi } from '@backstage/core-plugin-api';
import { PropsWithChildren } from 'react';
import { default as React_2 } from 'react';
import { ReactNode } from 'react';
import { SessionApi } from '@backstage/core-plugin-api';
import { SessionState } from '@backstage/core-plugin-api';
import { SignInPageProps } from '@backstage/core-plugin-api';
import { StorageApi } from '@backstage/core-plugin-api';
import { storageApiRef } from '@backstage/core-plugin-api';
import { StorageValueSnapshot } from '@backstage/core-plugin-api';
import { TypesToApiRefs } from '@backstage/core-plugin-api';
import { useApi } from '@backstage/core-plugin-api';
import { useApiHolder } from '@backstage/core-plugin-api';
import { withApis } from '@backstage/core-plugin-api';
import { z } from 'zod';
import { ZodSchema } from 'zod';
import { ZodTypeDef } from 'zod';

export { AlertApi };

export { alertApiRef };

export { AlertMessage };

// @public
export type AnalyticsApi = {
  captureEvent(event: AnalyticsEvent): void;
};

// @public
export const analyticsApiRef: ApiRef<AnalyticsApi>;

// @public
export const AnalyticsContext: (options: {
  attributes: Partial<AnalyticsContextValue>;
  children: ReactNode;
}) => React_2.JSX.Element;

// @public
export type AnalyticsContextValue = CommonAnalyticsContext & {
  [param in string]: string | boolean | number | undefined;
};

// @public
export type AnalyticsEvent = {
  action: string;
  subject: string;
  value?: number;
  attributes?: AnalyticsEventAttributes;
  context: AnalyticsContextValue;
};

// @public
export type AnalyticsEventAttributes = {
  [attribute in string]: string | boolean | number;
};

// @public
export type AnalyticsTracker = {
  captureEvent: (
    action: string,
    subject: string,
    options?: {
      value?: number;
      attributes?: AnalyticsEventAttributes;
    },
  ) => void;
};

export { AnyApiFactory };

export { AnyApiRef };

// @public (undocumented)
export type AnyExtensionDataMap = {
  [name in string]: ExtensionDataRef<
    unknown,
    {
      optional?: true;
    }
  >;
};

// @public (undocumented)
export type AnyExtensionInputMap = {
  [inputName in string]: ExtensionInput<
    AnyExtensionDataMap,
    {
      optional: boolean;
      singleton: boolean;
    }
  >;
};

// @public (undocumented)
export type AnyExternalRoutes = {
  [name in string]: ExternalRouteRef;
};

// @public
export type AnyRouteRefParams =
  | {
      [param in string]: string;
    }
  | undefined;

// @public (undocumented)
export type AnyRoutes = {
  [name in string]: RouteRef;
};

export { ApiFactory };

export { ApiHolder };

export { ApiRef };

export { ApiRefConfig };

// @public
export interface AppNode {
  readonly edges: AppNodeEdges;
  readonly instance?: AppNodeInstance;
  readonly spec: AppNodeSpec;
}

// @public
export interface AppNodeEdges {
  // (undocumented)
  readonly attachedTo?: {
    node: AppNode;
    input: string;
  };
  // (undocumented)
  readonly attachments: ReadonlyMap<string, AppNode[]>;
}

// @public
export interface AppNodeInstance {
  getData<T>(ref: ExtensionDataRef<T>): T | undefined;
  getDataRefs(): Iterable<ExtensionDataRef<unknown>>;
}

// @public
export interface AppNodeSpec {
  // (undocumented)
  readonly attachTo: {
    id: string;
    input: string;
  };
  // (undocumented)
  readonly config?: unknown;
  // (undocumented)
  readonly disabled: boolean;
  // (undocumented)
  readonly extension: Extension<unknown>;
  // (undocumented)
  readonly id: string;
  // (undocumented)
  readonly source?: BackstagePlugin;
}

export { AppTheme };

export { AppThemeApi };

export { appThemeApiRef };

// @public
export interface AppTree {
  readonly nodes: ReadonlyMap<string, AppNode>;
  readonly orphans: Iterable<AppNode>;
  readonly root: AppNode;
}

// @public
export interface AppTreeApi {
  getTree(): {
    tree: AppTree;
  };
}

// @public
export const appTreeApiRef: ApiRef<AppTreeApi>;

export { atlassianAuthApiRef };

export { AuthProviderInfo };

export { AuthRequestOptions };

export { BackstageIdentityApi };

export { BackstageIdentityResponse };

// @public (undocumented)
export interface BackstagePlugin<
  Routes extends AnyRoutes = AnyRoutes,
  ExternalRoutes extends AnyExternalRoutes = AnyExternalRoutes,
> {
  // (undocumented)
  readonly $$type: '@backstage/BackstagePlugin';
  // (undocumented)
  readonly externalRoutes: ExternalRoutes;
  // (undocumented)
  readonly id: string;
  // (undocumented)
  readonly routes: Routes;
}

export { BackstageUserIdentity };

export { bitbucketAuthApiRef };

export { bitbucketServerAuthApiRef };

// @public
export type CommonAnalyticsContext = {
  pluginId: string;
  extensionId: string;
};

// @public (undocumented)
export type ComponentRef<T> = {
  id: string;
  T: T;
};

// @public
export interface ComponentsApi {
  // (undocumented)
  getComponent<T>(ref: ComponentRef<T>): T;
}

// @public
export const componentsApiRef: ApiRef<ComponentsApi>;

export { ConfigApi };

export { configApiRef };

// @public (undocumented)
export interface ConfigurableExtensionDataRef<
  TData,
  TConfig extends {
    optional?: true;
  } = {},
> extends ExtensionDataRef<TData, TConfig> {
  // (undocumented)
  optional(): ConfigurableExtensionDataRef<
    TData,
    TData & {
      optional: true;
    }
  >;
}

// @public (undocumented)
export type CoreBootErrorPageComponent = ComponentType<
  PropsWithChildren<{
    step: 'load-config' | 'load-chunk';
    error: Error;
  }>
>;

// @public (undocumented)
export const coreComponentsRefs: {
  progress: ComponentRef<CoreProgressComponent>;
  bootErrorPage: ComponentRef<CoreBootErrorPageComponent>;
  notFoundErrorPage: ComponentRef<CoreNotFoundErrorPageComponent>;
  errorBoundaryFallback: ComponentRef<CoreErrorBoundaryFallbackComponent>;
};

// @public (undocumented)
export type CoreErrorBoundaryFallbackComponent = ComponentType<
  PropsWithChildren<{
    plugin?: BackstagePlugin_2;
    error: Error;
    resetError: () => void;
  }>
>;

// @public (undocumented)
export const coreExtensionData: {
  reactElement: ConfigurableExtensionDataRef<JSX_2.Element, {}>;
  routePath: ConfigurableExtensionDataRef<string, {}>;
  apiFactory: ConfigurableExtensionDataRef<AnyApiFactory, {}>;
  routeRef: ConfigurableExtensionDataRef<RouteRef<AnyRouteRefParams>, {}>;
  navTarget: ConfigurableExtensionDataRef<NavTarget, {}>;
  theme: ConfigurableExtensionDataRef<AppTheme, {}>;
  logoElements: ConfigurableExtensionDataRef<LogoElements, {}>;
  component: ConfigurableExtensionDataRef<
    {
      ref: ComponentRef<ComponentType<any>>;
      impl: ComponentType<any>;
    },
    {}
  >;
};

// @public (undocumented)
export type CoreNotFoundErrorPageComponent = ComponentType<
  PropsWithChildren<{}>
>;

// @public (undocumented)
export type CoreProgressComponent = ComponentType<PropsWithChildren<{}>>;

// @public (undocumented)
export function createApiExtension<
  TConfig extends {},
  TInputs extends AnyExtensionInputMap,
>(
  options: (
    | {
        api: AnyApiRef;
        factory: (options: {
          config: TConfig;
          inputs: Expand<ResolvedExtensionInputs<TInputs>>;
        }) => AnyApiFactory;
      }
    | {
        factory: AnyApiFactory;
      }
  ) & {
    configSchema?: PortableSchema<TConfig>;
    inputs?: TInputs;
  },
): ExtensionDefinition<TConfig>;

export { createApiFactory };

export { createApiRef };

// @public (undocumented)
export function createComponentExtension<
  TRef extends ComponentRef<any>,
  TConfig extends {},
  TInputs extends AnyExtensionInputMap,
>(options: {
  ref: TRef;
  name?: string;
  disabled?: boolean;
  inputs?: TInputs;
  configSchema?: PortableSchema<TConfig>;
  component:
    | {
        lazy: (values: {
          config: TConfig;
          inputs: Expand<ResolvedExtensionInputs<TInputs>>;
        }) => Promise<TRef['T']>;
      }
    | {
        sync: (values: {
          config: TConfig;
          inputs: Expand<ResolvedExtensionInputs<TInputs>>;
        }) => TRef['T'];
      };
}): ExtensionDefinition<TConfig>;

// @public (undocumented)
export function createExtension<
  TOutput extends AnyExtensionDataMap,
  TInputs extends AnyExtensionInputMap,
  TConfig = never,
>(
  options: CreateExtensionOptions<TOutput, TInputs, TConfig>,
): ExtensionDefinition<TConfig>;

// @public (undocumented)
export function createExtensionDataRef<TData>(
  id: string,
): ConfigurableExtensionDataRef<TData>;

// @public (undocumented)
export function createExtensionInput<
  TExtensionData extends AnyExtensionDataMap,
  TConfig extends {
    singleton?: boolean;
    optional?: boolean;
  },
>(
  extensionData: TExtensionData,
  config?: TConfig,
): ExtensionInput<
  TExtensionData,
  {
    singleton: TConfig['singleton'] extends true ? true : false;
    optional: TConfig['optional'] extends true ? true : false;
  }
>;

// @public (undocumented)
export interface CreateExtensionOptions<
  TOutput extends AnyExtensionDataMap,
  TInputs extends AnyExtensionInputMap,
  TConfig,
> {
  // (undocumented)
  attachTo: {
    id: string;
    input: string;
  };
  // (undocumented)
  configSchema?: PortableSchema<TConfig>;
  // (undocumented)
  disabled?: boolean;
  // (undocumented)
  factory(options: {
    node: AppNode;
    config: TConfig;
    inputs: Expand<ResolvedExtensionInputs<TInputs>>;
  }): Expand<ExtensionDataValues<TOutput>>;
  // (undocumented)
  inputs?: TInputs;
  // (undocumented)
  kind?: string;
  // (undocumented)
  name?: string;
  // (undocumented)
  namespace?: string;
  // (undocumented)
  output: TOutput;
}

// @public (undocumented)
export function createExtensionOverrides(
  options: ExtensionOverridesOptions,
): ExtensionOverrides;

// @public
export function createExternalRouteRef<
  TParams extends
    | {
        [param in TParamKeys]: string;
      }
    | undefined = undefined,
  TOptional extends boolean = false,
  TParamKeys extends string = string,
>(options?: {
  readonly params?: string extends TParamKeys
    ? (keyof TParams)[]
    : TParamKeys[];
  optional?: TOptional;
}): ExternalRouteRef<
  keyof TParams extends never
    ? undefined
    : string extends TParamKeys
    ? TParams
    : {
        [param in TParamKeys]: string;
      },
  TOptional
>;

// @public
export function createNavItemExtension(options: {
  namespace?: string;
  name?: string;
  routeRef: RouteRef<undefined>;
  title: string;
  icon: IconComponent_2;
}): ExtensionDefinition<{
  title: string;
}>;

// @public
export function createPageExtension<
  TConfig extends {
    path: string;
  },
  TInputs extends AnyExtensionInputMap,
>(
  options: (
    | {
        defaultPath: string;
      }
    | {
        configSchema: PortableSchema<TConfig>;
      }
  ) & {
    namespace?: string;
    name?: string;
    attachTo?: {
      id: string;
      input: string;
    };
    disabled?: boolean;
    inputs?: TInputs;
    routeRef?: RouteRef;
    loader: (options: {
      config: TConfig;
      inputs: Expand<ResolvedExtensionInputs<TInputs>>;
    }) => Promise<JSX.Element>;
  },
): ExtensionDefinition<TConfig>;

// @public (undocumented)
export function createPlugin<
  Routes extends AnyRoutes = {},
  ExternalRoutes extends AnyExternalRoutes = {},
>(
  options: PluginOptions<Routes, ExternalRoutes>,
): BackstagePlugin<Routes, ExternalRoutes>;

// @public
export function createRouteRef<
  TParams extends
    | {
        [param in TParamKeys]: string;
      }
    | undefined = undefined,
  TParamKeys extends string = string,
>(config?: {
  readonly params: string extends TParamKeys ? (keyof TParams)[] : TParamKeys[];
}): RouteRef<
  keyof TParams extends never
    ? undefined
    : string extends TParamKeys
    ? TParams
    : {
        [param in TParamKeys]: string;
      }
>;

// @public (undocumented)
export function createSchemaFromZod<TOutput, TInput>(
  schemaCreator: (zImpl: typeof z) => ZodSchema<TOutput, ZodTypeDef, TInput>,
): PortableSchema<TOutput>;

// @public (undocumented)
export function createSignInPageExtension<
  TConfig extends {},
  TInputs extends AnyExtensionInputMap,
>(options: {
  namespace?: string;
  name?: string;
  attachTo?: {
    id: string;
    input: string;
  };
  configSchema?: PortableSchema<TConfig>;
  disabled?: boolean;
  inputs?: TInputs;
  loader: (options: {
    config: TConfig;
    inputs: Expand<ResolvedExtensionInputs<TInputs>>;
  }) => Promise<ComponentType<SignInPageProps>>;
}): ExtensionDefinition<TConfig>;

// @public
export function createSubRouteRef<
  Path extends string,
  ParentParams extends AnyRouteRefParams = never,
>(config: {
  path: Path;
  parent: RouteRef<ParentParams>;
}): MakeSubRouteRef<PathParams<Path>, ParentParams>;

// @public (undocumented)
export function createThemeExtension(
  theme: AppTheme,
): ExtensionDefinition<never>;

export { DiscoveryApi };

export { discoveryApiRef };

export { ErrorApi };

export { ErrorApiError };

export { ErrorApiErrorContext };

export { errorApiRef };

// @public (undocumented)
export interface Extension<TConfig> {
  // (undocumented)
  $$type: '@backstage/Extension';
  // (undocumented)
  attachTo: {
    id: string;
    input: string;
  };
  // (undocumented)
  configSchema?: PortableSchema<TConfig>;
  // (undocumented)
  disabled: boolean;
  // (undocumented)
  factory(options: {
    node: AppNode;
    config: TConfig;
    inputs: ResolvedExtensionInputs<any>;
  }): ExtensionDataValues<any>;
  // (undocumented)
  id: string;
  // (undocumented)
  inputs: AnyExtensionInputMap;
  // (undocumented)
  output: AnyExtensionDataMap;
}

// @public (undocumented)
export function ExtensionBoundary(
  props: ExtensionBoundaryProps,
): React_2.JSX.Element;

// @public (undocumented)
export interface ExtensionBoundaryProps {
  // (undocumented)
  children: ReactNode;
  // (undocumented)
  node: AppNode;
  // (undocumented)
  routable?: boolean;
}

// @public (undocumented)
export type ExtensionDataRef<
  TData,
  TConfig extends {
    optional?: true;
  } = {},
> = {
  id: string;
  T: TData;
  config: TConfig;
  $$type: '@backstage/ExtensionDataRef';
};

// @public
export type ExtensionDataValues<TExtensionData extends AnyExtensionDataMap> = {
  [DataName in keyof TExtensionData as TExtensionData[DataName]['config'] extends {
    optional: true;
  }
    ? never
    : DataName]: TExtensionData[DataName]['T'];
} & {
  [DataName in keyof TExtensionData as TExtensionData[DataName]['config'] extends {
    optional: true;
  }
    ? DataName
    : never]?: TExtensionData[DataName]['T'];
};

// @public (undocumented)
export interface ExtensionDefinition<TConfig> {
  // (undocumented)
  $$type: '@backstage/ExtensionDefinition';
  // (undocumented)
  attachTo: {
    id: string;
    input: string;
  };
  // (undocumented)
  configSchema?: PortableSchema<TConfig>;
  // (undocumented)
  disabled: boolean;
  // (undocumented)
  factory(options: {
    node: AppNode;
    config: TConfig;
    inputs: ResolvedExtensionInputs<any>;
  }): ExtensionDataValues<any>;
  // (undocumented)
  inputs: AnyExtensionInputMap;
  // (undocumented)
  kind?: string;
  // (undocumented)
  name?: string;
  // (undocumented)
  namespace?: string;
  // (undocumented)
  output: AnyExtensionDataMap;
}

// @public (undocumented)
export interface ExtensionInput<
  TExtensionData extends AnyExtensionDataMap,
  TConfig extends {
    singleton: boolean;
    optional: boolean;
  },
> {
  // (undocumented)
  $$type: '@backstage/ExtensionInput';
  // (undocumented)
  config: TConfig;
  // (undocumented)
  extensionData: TExtensionData;
}

// @public (undocumented)
export interface ExtensionOverrides {
  // (undocumented)
  readonly $$type: '@backstage/ExtensionOverrides';
}

// @public (undocumented)
export interface ExtensionOverridesOptions {
  // (undocumented)
  extensions: ExtensionDefinition<unknown>[];
  // (undocumented)
  featureFlags?: FeatureFlagConfig[];
}

// @public
export interface ExternalRouteRef<
  TParams extends AnyRouteRefParams = AnyRouteRefParams,
  TOptional extends boolean = boolean,
> {
  // (undocumented)
  readonly $$type: '@backstage/ExternalRouteRef';
  // (undocumented)
  readonly optional: TOptional;
  // (undocumented)
  readonly T: TParams;
}

export { FeatureFlag };

// @public
export type FeatureFlagConfig = {
  name: string;
};

export { FeatureFlagsApi };

export { featureFlagsApiRef };

export { FeatureFlagsSaveOptions };

export { FeatureFlagState };

export { FetchApi };

export { fetchApiRef };

export { githubAuthApiRef };

export { gitlabAuthApiRef };

export { googleAuthApiRef };

// @public
export type IconComponent = ComponentType<
  | {
      fontSize?: 'large' | 'small' | 'default' | 'inherit';
    }
  | {
      fontSize?: 'medium' | 'large' | 'small' | 'inherit';
    }
>;

export { IdentityApi };

export { identityApiRef };

// @public (undocumented)
export type LogoElements = {
  logoIcon?: JSX_2.Element;
  logoFull?: JSX_2.Element;
};

export { microsoftAuthApiRef };

// @public (undocumented)
export type NavTarget = {
  title: string;
  icon: IconComponent_2;
  routeRef: RouteRef<undefined>;
};

export { OAuthApi };

export { OAuthRequestApi };

export { oauthRequestApiRef };

export { OAuthRequester };

export { OAuthRequesterOptions };

export { OAuthScope };

export { oktaAuthApiRef };

export { oneloginAuthApiRef };

export { OpenIdConnectApi };

export { PendingOAuthRequest };

// @public (undocumented)
export interface PluginOptions<
  Routes extends AnyRoutes,
  ExternalRoutes extends AnyExternalRoutes,
> {
  // (undocumented)
  extensions?: ExtensionDefinition<unknown>[];
  // (undocumented)
  externalRoutes?: ExternalRoutes;
  // (undocumented)
  featureFlags?: FeatureFlagConfig[];
  // (undocumented)
  id: string;
  // (undocumented)
  routes?: Routes;
}

// @public (undocumented)
export type PortableSchema<TOutput> = {
  parse: (input: unknown) => TOutput;
  schema: JsonObject;
};

export { ProfileInfo };

export { ProfileInfoApi };

// @public
export type ResolvedExtensionInput<TExtensionData extends AnyExtensionDataMap> =
  {
    extensionId: string;
    output: ExtensionDataValues<TExtensionData>;
  };

// @public
export type ResolvedExtensionInputs<
  TInputs extends {
    [name in string]: ExtensionInput<any, any>;
  },
> = {
  [InputName in keyof TInputs]: false extends TInputs[InputName]['config']['singleton']
    ? Array<Expand<ResolvedExtensionInput<TInputs[InputName]['extensionData']>>>
    : false extends TInputs[InputName]['config']['optional']
    ? Expand<ResolvedExtensionInput<TInputs[InputName]['extensionData']>>
    : Expand<
        ResolvedExtensionInput<TInputs[InputName]['extensionData']> | undefined
      >;
};

// @public
export type RouteFunc<TParams extends AnyRouteRefParams> = (
  ...[params]: TParams extends undefined
    ? readonly []
    : readonly [params: TParams]
) => string;

// @public
export interface RouteRef<
  TParams extends AnyRouteRefParams = AnyRouteRefParams,
> {
  // (undocumented)
  readonly $$type: '@backstage/RouteRef';
  // (undocumented)
  readonly T: TParams;
}

export { SessionApi };

export { SessionState };

export { StorageApi };

export { storageApiRef };

export { StorageValueSnapshot };

// @public
export interface SubRouteRef<
  TParams extends AnyRouteRefParams = AnyRouteRefParams,
> {
  // (undocumented)
  readonly $$type: '@backstage/SubRouteRef';
  // (undocumented)
  readonly path: string;
  // (undocumented)
  readonly T: TParams;
}

export { TypesToApiRefs };

// @public
export function useAnalytics(): AnalyticsTracker;

export { useApi };

export { useApiHolder };

// @public
export function useRouteRef<
  TOptional extends boolean,
  TParams extends AnyRouteRefParams,
>(
  routeRef: ExternalRouteRef<TParams, TOptional>,
): TParams extends true ? RouteFunc<TParams> | undefined : RouteFunc<TParams>;

// @public
export function useRouteRef<TParams extends AnyRouteRefParams>(
  routeRef: RouteRef<TParams> | SubRouteRef<TParams>,
): RouteFunc<TParams>;

// @public
export function useRouteRefParams<Params extends AnyRouteRefParams>(
  _routeRef: RouteRef<Params> | SubRouteRef<Params>,
): Params;

export { withApis };
```
